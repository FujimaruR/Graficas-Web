<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/Front/recursos/icono.png">
    <title>INFINITE SPACE</title>
    <link rel="stylesheet" href="/Front/css/MainGame.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>

<body>
    <div class="contenedor-todo">
        <div class="caja-blanca" id="MostrarMap">
            <!--<img src="/Front/recursos/cuadro-blanco.png.jpg" alt="invalid-img" class="box" id="box">-->
        </div>

        <div class="letra">
            <img src="/Front/recursos/PUNTOS.png" alt="invalid-img" class="box1" id="box1">
        </div>

        <a href="MenuPause.html">
            <div class="pause">
                <img src="/Front/recursos/pausa (3).png" alt="invalid-img" class="box5" id="box5">
            </div>
        </a>

        <div class="logo">
            <img src="/Front/recursos/logo.png" alt="initial-scale" class="box6" id="box6">
        </div>

        <div class="players">
            <img src="/Front/recursos/Imagenes/1jugadores.png" alt="invalid-img" class="box5" id="box7">
        </div>

        <div id="score">Puntos: 0</div>
    </div>

    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>-->

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
    <!--<script src="/Back/MainGame.js"></script>-->

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OBJLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/OBJLoader';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls';

        // Crear una escena
        const scene = new THREE.Scene();

        // Crear una cámara
        // Crear una cámara
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 110); // Posición de la cámara
        camera.lookAt(0, 0, 0); // Mirar hacia el origen de la escena


        // Crear un renderizador con dimensiones específicas
        const renderer = new THREE.WebGLRenderer({ width: 800, height: 600 });
        renderer.setSize(800, 600);
        document.getElementById('MostrarMap').appendChild(renderer.domElement);


        // Agregar una luz ambiental
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Color, intensidad
        scene.add(ambientLight);

        // Agregar una luz direccional
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // Color, intensidad
        directionalLight.position.set(0, 1, 0); // Posición de la luz
        scene.add(directionalLight);

        // Crear controles de órbita
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Suavizado del movimiento de los controles
        controls.dampingFactor = 0.25; // Factor de amortiguación

        // Cargar la textura del fondo
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const imagen = urlParams.get('imagen');
        const textureLoader = new THREE.TextureLoader();
        const texture = textureLoader.load('/Front/recursos/Mapas/' + imagen);

        // Crear un material con la textura del fondo
        const backgroundMaterial = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });

        // Crear un cubo grande para el fondo
        const backgroundGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
        const backgroundCube = new THREE.Mesh(backgroundGeometry, backgroundMaterial);

        // Agregar el cubo del fondo a la escena
        scene.add(backgroundCube);


        let object;

        // Cargar el modelo OBJ
        const loader = new OBJLoader();
        loader.load(
            '/Front/recursos/Modelos/Cohete1/10475_Rocket_Ship_v1_L3.obj',
            function (loadedObject) {

                object = loadedObject;

                // Cargar la textura para el modelo
                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load('/Front/recursos/Modelos/Cohete1/10475_Rocket_Ship_v1_Diffuse.jpg');

                // Crear un material con la textura cargada
                const material = new THREE.MeshBasicMaterial({ map: texture });

                // Aplicar el material al objeto
                object.traverse(function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                });

                // Ajustar la posición del modelo
                object.position.set(-45, -78, 0); // Modificar según sea necesario
                object.rotation.set(180, -0.1, 0.3);

                // Ajustar la escala del modelo
                object.scale.set(0.1, 0.1, 0.1); // Modificar según sea necesario

                scene.add(object);
            },
            function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (error) {
                console.error('Error loading OBJ file:', error);
            }
        );

        function getRandomPosition() {
            const x = Math.random() * 100 - 70; // Ajusta según el tamaño del área de juego
            const y = Math.random() * 100 - 60; // Ajusta según el tamaño del área de juego
            return { x, y };
        }

        let objectSol;

        const enemyBullets = [];
        let numBullets = 0;

        if (urlParams.has('imagen') && urlParams.get('imagen') === 'MicrosoftTeams-image (1).png') {
            console.log('Balas: 5');
            numBullets = 5;
        } else {
            console.log('Balas: 7');
            numBullets = 7;
        }
        const loaderDos = new OBJLoader();
        const redTextureLoader = new THREE.TextureLoader();
        const redTexture = redTextureLoader.load('/Front/recursos/Modelos/Bala/rojo.jpeg');


        loaderDos.load('/Front/recursos/Modelos/Bala/sol.obj', (loadedObjectD) => {
            for (let i = 0; i < numBullets; i++) {
                const bullet = new EnemyBullet(loadedObjectD, redTexture);
                enemyBullets.push(bullet);
            }
        });

        let modelo1, modelo2, modelo3; // Variables para almacenar los modelos

        // Cargar el modelo 1
        const loaderModelo1 = new OBJLoader();
        loaderModelo1.load(
            '/Front/recursos/Modelos/Escudo/Sci-Fi_CAP.obj',
            function (loadedObject) {
                modelo1 = loadedObject;

                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load('/Front/recursos/Modelos/Escudo/BaseColor.png');

                // Crear un material con la textura cargada
                const material = new THREE.MeshBasicMaterial({ map: texture });

                // Aplicar el material al objeto
                modelo1.traverse(function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                });
                // Configurar posición, escala, rotación, etc., según sea necesario
                const position = getRandomPosition();
                modelo1.position.set(position.x, position.y, 0);
                modelo1.scale.set(0.6, 0.6, 0.6);
                modelo1.rotation.set(-80, -0.1, 0.3);
                // Agregar el modelo a la escena
                scene.add(modelo1);
            },
            function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (error) {
                console.error('Error loading OBJ file for modelo1:', error);
            }
        );

        // Cargar el modelo 2
        const loaderModelo2 = new OBJLoader();
        loaderModelo2.load(
            '/Front/recursos/Modelos/Rayo/Rayo.obj',
            function (loadedObject) {
                modelo2 = loadedObject;

                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load('/Front/recursos/Modelos/Rayo/Amarillo.png');

                // Crear un material con la textura cargada
                const material = new THREE.MeshBasicMaterial({ map: texture });

                // Aplicar el material al objeto
                modelo2.traverse(function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                });
                // Configurar posición, escala, rotación, etc., según sea necesario
                const position = getRandomPosition();
                modelo2.position.set(position.x, position.y, 0);
                modelo2.scale.set(2, 2, 2);
                // Agregar el modelo a la escena
                scene.add(modelo2);
            },
            function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (error) {
                console.error('Error loading OBJ file for modelo2:', error);
            }
        );

        // Cargar el modelo 3
        const loaderModelo3 = new OBJLoader();
        loaderModelo3.load(
            '/Front/recursos/Modelos/Reloj/HourglassWSand0.obj',
            function (loadedObject) {
                modelo3 = loadedObject;

                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load('/Front/recursos/Modelos/Bala/rojo.jpeg');

                // Crear un material con la textura cargada
                const material = new THREE.MeshBasicMaterial({ map: texture });

                // Aplicar el material al objeto
                modelo3.traverse(function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                });
                // Configurar posición, escala, rotación, etc., según sea necesario
                const position = getRandomPosition();
                modelo3.position.set(position.x, position.y, 0);
                modelo3.scale.set(5, 5, 5);
                // Agregar el modelo a la escena
                scene.add(modelo3);
            },
            function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (error) {
                console.error('Error loading OBJ file for modelo3:', error);
            }
        );

        const keysState = {};

        // Escuchar eventos de teclado
        document.addEventListener('keydown', (event) => {
            // Marcar la tecla como activa en el objeto keysState
            keysState[event.key] = true;
        });

        document.addEventListener('keyup', (event) => {
            // Desmarcar la tecla como activa en el objeto keysState
            keysState[event.key] = false;
        });

        let lateralSpeed = 1;
        let VerticalSpeed = 1;
        let rotationSpeedX = 0.001;
        let rotationSpeedY = 0.001;
        const box1 = new THREE.Box3();
        const box2 = new THREE.Box3();

        class EnemyBullet {
            constructor(model, texture) {
                this.model = model.clone();
                const material = new THREE.MeshBasicMaterial({ map: texture });
                this.model.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                });
                this.model.scale.set(0.0002, 0.0002, 0.0002);
                scene.add(this.model);  // Aseguramos que el modelo esté en la escena antes de crear la caja de colisión
                this.box = new THREE.Box3();
                this.resetPosition();
            }

            resetPosition() {
                const startX = Math.random() * 800 - 400;
                const startY = Math.random() * 600 - 300;
                if (Math.random() < 0.5) {
                    this.model.position.set(startX, Math.random() < 0.5 ? -300 : 300, 0);
                } else {
                    this.model.position.set(Math.random() < 0.5 ? -400 : 400, startY, 0);
                }
                this.direction = new THREE.Vector3(0, 0, 0).sub(this.model.position).normalize();
                this.box.setFromObject(this.model);
            }

            update() {
                this.model.position.add(this.direction.clone().multiplyScalar(1)); // Ajusta la velocidad multiplicando por un factor
                this.box.setFromObject(this.model);

                if (this.model.position.x < -400 || this.model.position.x > 400 || this.model.position.y < -300 || this.model.position.y > 300) {
                    this.resetPosition();
                }
            }
        }

        let score = 0;
        let isPaused = false;
        let isPausedDos = false;

        let Dead = false;
        let DeadDos = false;

        let invulnerableTime = 0;
        let slowBulletTime = 0;
        let speedBoostTime = 0;

        function checkCollisions() {
            if (!object) return false;

            const rocketBox = new THREE.Box3().setFromObject(object);

            if (modelo1) {
                const escudoBox = new THREE.Box3().setFromObject(modelo1);
                if (rocketBox.intersectsBox(escudoBox)) {
                    if (invulnerableTime <= 0) {
                        invulnerableTime = 16 * 60;
                        console.log('Colisión detectada con escudo');
                        modelo1.visible = false;
                    }
                }
            }

            if (modelo2) {
                const rayoBox = new THREE.Box3().setFromObject(modelo2);
                if (rocketBox.intersectsBox(rayoBox)) {
                    if (speedBoostTime <= 0) {
                        speedBoostTime = 16 * 60;

                        lateralSpeed *= 2;
                        VerticalSpeed *= 2;
                        console.log('Colisión detectada con rayo');
                        modelo2.visible = false;
                    }
                }
            }

            if (modelo3) {
                const relojBox = new THREE.Box3().setFromObject(modelo3);
                if (rocketBox.intersectsBox(relojBox)) {
                    if (slowBulletTime <= 0) {
                        slowBulletTime = 16 * 60;
                        console.log('Colisión detectada con reloj');
                        for (const bullet of enemyBullets) {
                            bullet.direction.multiplyScalar(0.5); // Ralentizar la velocidad de las balas a la mitad
                        }
                        modelo3.visible = false;
                    }
                }
            }

            if (invulnerableTime <= 0) {
                for (const bullet of enemyBullets) {
                    if (rocketBox.intersectsBox(bullet.box)) {
                        if (urlParams.has('jugadores') && urlParams.get('jugadores') === '1') {
                            localStorage.setItem('username', 'indefinido');
                            localStorage.setItem('Puntuacion', score);

                            window.location.href = `MenuDead.html?score=${score}`;

                        } else if (isPausedDos === false) {
                            Dead = true;
                        } else if (isPausedDos === true) {
                            Dead = true;
                            localStorage.setItem('username', 'indefinido');
                            localStorage.setItem('Puntuacion', score);

                            window.location.href = `MenuDead.html?score=${score}`;
                        } else {
                            Dead = true;
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        // Función de animación
        function animate() {
            if (Dead === true) {
                return;
            }
            requestAnimationFrame(animate);

            if (invulnerableTime > 0) {
                invulnerableTime -= 1;
                if (invulnerableTime <= 0) {
                    const positionE = getRandomPosition();
                    modelo1.position.set(positionE.x, positionE.y, 0);
                    modelo1.visible = true;
                }
            }

            if (slowBulletTime > 0) {
                slowBulletTime -= 1;
                if (slowBulletTime <= 0) {
                    for (const bullet of enemyBullets) {
                        bullet.speed *= 2; // Restaurar la velocidad de las balas
                    }
                    const positionR = getRandomPosition();
                    modelo3.position.set(positionR.x, positionR.y, 0);
                    modelo3.visible = true; // Hacer visible el rayo de nuevo
                }
            }

            if (speedBoostTime > 0) {
                speedBoostTime -= 1;
                if (speedBoostTime <= 0) {
                    lateralSpeed /= 2; // Restaurar la velocidad lateral del cohete
                    VerticalSpeed /= 2; // Restaurar la velocidad vertical del cohete
                    const positionS = getRandomPosition();
                    modelo2.position.set(positionS.x, positionS.y, 0);
                    modelo2.visible = true; // Hacer visible el reloj de nuevo
                }
            }

            backgroundCube.rotation.x += rotationSpeedX;
            backgroundCube.rotation.y += rotationSpeedY;

            if (keysState['a'] || keysState['A']) {
                // Mover el modelo hacia la izquierda
                if (object && object.position.x - lateralSpeed >= -150) {
                    object.position.x -= lateralSpeed;
                }
            }
            if (keysState['d'] || keysState['D']) {
                // Mover el modelo hacia la derecha
                if (object && object.position.x + lateralSpeed <= 80) {
                    object.position.x += lateralSpeed;
                }
            }
            if (keysState['w'] || keysState['W']) {
                // Mover el modelo hacia arriba
                if (object && object.position.x + VerticalSpeed <= 70) {
                    object.position.y += VerticalSpeed;
                }
            }
            if (keysState['s'] || keysState['S']) {
                // Mover el modelo hacia abajo
                if (object && object.position.x + VerticalSpeed >= -100) {
                    object.position.y -= VerticalSpeed;
                }
            }

            if (object) {
                box1.setFromObject(object);
                enemyBullets.forEach((bullet) => {
                    bullet.update(object);
                    if (box1.intersectsBox(bullet.box)) {
                        console.log('Colisión detectada');
                    }
                });
            }

            /*moveBullet();*/
            controls.update(); // Actualizar controles de órbita
            renderer.render(scene, camera);

            if (!isPaused) {
                score++;
                document.getElementById('score').innerText = `Puntos: ${score}`;
            }

            if (checkCollisions()) {
                isPaused = true;
            }
        }
        animate();

        // Obtener la consulta de la URL

        // Verificar si el parámetro 'jugadores' está presente y tiene el valor 2
        if (urlParams.has('jugadores') && urlParams.get('jugadores') === '2') {

            var segundaCajaBlanca = document.createElement('div');
            segundaCajaBlanca.className = 'caja-blanca segunda-caja-blanca'; // Asigna una clase diferente para el segundo contenedor
            segundaCajaBlanca.id = 'box2'
            document.body.appendChild(segundaCajaBlanca);

            var secondScore = document.createElement('div');
            secondScore.id = 'scoreD'
            document.body.appendChild(secondScore);

            var primeraCajaBlanca = document.querySelector('.caja-blanca');
            primeraCajaBlanca.style.right = '55%';

            var firstScore = document.getElementById('score');
            firstScore.style.right = '60%';

            // Crear una segunda escena, cámara y renderizador
            const secondScene = new THREE.Scene();
            const secondCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            secondCamera.position.set(0, 0, 110);
            secondCamera.lookAt(0, 0, 0);
            const secondRenderer = new THREE.WebGLRenderer({ width: 800, height: 600 });
            secondRenderer.setSize(800, 600);
            document.getElementById('box2').appendChild(secondRenderer.domElement);

            // Crear una segunda luz ambiental y direccional
            const secondAmbientLight = new THREE.AmbientLight(0xffffff, 0.5);
            secondScene.add(secondAmbientLight);
            const secondDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            secondDirectionalLight.position.set(0, 1, 0);
            secondScene.add(secondDirectionalLight);

            const imagend = urlParams.get('imagen');
            const textureLoaderd = new THREE.TextureLoader();
            const textured = textureLoaderd.load('/Front/recursos/Mapas/' + imagend);

            // Crear un material con la textura del fondo
            const backgroundMateriald = new THREE.MeshBasicMaterial({ map: textured, side: THREE.BackSide });

            // Crear un cubo grande para el fondo
            const backgroundGeometryd = new THREE.BoxGeometry(1000, 1000, 1000);
            const backgroundCubed = new THREE.Mesh(backgroundGeometryd, backgroundMateriald);

            // Agregar el cubo del fondo a la escena
            secondScene.add(backgroundCubed);

            let secondObject;

            // Cargar el modelo OBJ en la segunda escena
            const secondLoader = new OBJLoader();
            secondLoader.load(
                '/Front/recursos/Modelos/Cohete2/Cohete2.obj',
                function (SecondloadedObject) {
                    secondObject = SecondloadedObject;
                    // Cargar la textura para el segundo modelo
                    const textureLoader = new THREE.TextureLoader();
                    const texture = textureLoader.load('/Front/recursos/Modelos/Cohete2/Textura2Cohete.jpg');

                    // Crear un material con la textura cargada
                    const material = new THREE.MeshBasicMaterial({ map: texture });

                    // Aplicar el material al objeto
                    secondObject.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.material = material;
                        }
                    });
                    secondObject.position.set(-45, -78, 0);
                    secondObject.rotation.set(180, -0.1, 0.3);
                    secondObject.scale.set(0.1, 0.1, 0.1);
                    secondScene.add(secondObject);
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('Error loading OBJ file:', error);
                }
            );

            const enemyBulletsDos = [];
            const loaderBalaDos = new OBJLoader();
            const redBalaTextureLoader = new THREE.TextureLoader();
            const redBalaTexture = redBalaTextureLoader.load('/Front/recursos/Modelos/Bala/rojo.jpeg');


            loaderBalaDos.load('/Front/recursos/Modelos/Bala/sol.obj', (loadedObjectBalaD) => {
                for (let i = 0; i < numBullets; i++) {
                    const bullet = new EnemyBulletDos(loadedObjectBalaD, redBalaTexture);
                    enemyBulletsDos.push(bullet);
                }
            });


            let secondModelo1, secondModelo2, secondModelo3;

            const loaderSecondModelo1 = new OBJLoader();
            loaderSecondModelo1.load(
                '/Front/recursos/Modelos/Escudo/Sci-Fi_CAP.obj',
                function (loadedObject) {
                    secondModelo1 = loadedObject;
                    const textureLoader = new THREE.TextureLoader();
                    const texture = textureLoader.load('/Front/recursos/Modelos/Escudo/BaseColor.png');
                    const material = new THREE.MeshBasicMaterial({ map: texture });

                    secondModelo1.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.material = material;
                        }
                    });

                    const position = getRandomPosition();
                    secondModelo1.position.set(position.x, position.y, 0);
                    secondModelo1.scale.set(0.6, 0.6, 0.6);
                    secondModelo1.rotation.set(-80, -0.1, 0.3);
                    secondScene.add(secondModelo1);
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('Error loading OBJ file for secondModelo1:', error);
                }
            );

            const loaderSecondModelo2 = new OBJLoader();
            loaderSecondModelo2.load(
                '/Front/recursos/Modelos/Rayo/Rayo.obj',
                function (loadedObject) {
                    secondModelo2 = loadedObject;
                    const textureLoader = new THREE.TextureLoader();
                    const texture = textureLoader.load('/Front/recursos/Modelos/Rayo/Amarillo.png');
                    const material = new THREE.MeshBasicMaterial({ map: texture });

                    secondModelo2.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.material = material;
                        }
                    });

                    const position = getRandomPosition();
                    secondModelo2.position.set(position.x, position.y, 0);
                    secondModelo2.scale.set(2, 2, 2);
                    secondScene.add(secondModelo2);
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('Error loading OBJ file for secondModelo2:', error);
                }
            );

            const loaderSecondModelo3 = new OBJLoader();
            loaderSecondModelo3.load(
                '/Front/recursos/Modelos/Reloj/HourglassWSand0.obj',
                function (loadedObject) {
                    secondModelo3 = loadedObject;
                    const textureLoader = new THREE.TextureLoader();
                    const texture = textureLoader.load('/Front/recursos/Modelos/Bala/rojo.jpeg');
                    const material = new THREE.MeshBasicMaterial({ map: texture });

                    secondModelo3.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.material = material;
                        }
                    });

                    const position = getRandomPosition();
                    secondModelo3.position.set(position.x, position.y, 0);
                    secondModelo3.scale.set(5, 5, 5);
                    secondScene.add(secondModelo3);
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('Error loading OBJ file for secondModelo3:', error);
                }
            );

            const keysStateDos = {};

            // Escuchar eventos de teclado
            document.addEventListener('keydown', (event) => {
                // Marcar la tecla como activa en el objeto keysState
                keysStateDos[event.key] = true;
            });

            document.addEventListener('keyup', (event) => {
                // Desmarcar la tecla como activa en el objeto keysState
                keysStateDos[event.key] = false;
            });


            const box3 = new THREE.Box3();

            class EnemyBulletDos {
                constructor(model, texture) {
                    this.model = model.clone();
                    const material = new THREE.MeshBasicMaterial({ map: texture });
                    this.model.traverse((child) => {
                        if (child instanceof THREE.Mesh) {
                            child.material = material;
                        }
                    });
                    this.model.scale.set(0.0002, 0.0002, 0.0002);
                    secondScene.add(this.model);  // Aseguramos que el modelo esté en la escena antes de crear la caja de colisión
                    this.box = new THREE.Box3();
                    this.resetPosition();
                }

                resetPosition() {
                    const startX = Math.random() * 800 - 400;
                    const startY = Math.random() * 600 - 300;
                    if (Math.random() < 0.5) {
                        this.model.position.set(startX, Math.random() < 0.5 ? -300 : 300, 0);
                    } else {
                        this.model.position.set(Math.random() < 0.5 ? -400 : 400, startY, 0);
                    }
                    this.direction = new THREE.Vector3(0, 0, 0).sub(this.model.position).normalize();
                    this.box.setFromObject(this.model);
                }

                update() {
                    this.model.position.add(this.direction.clone().multiplyScalar(1)); // Ajusta la velocidad multiplicando por un factor
                    this.box.setFromObject(this.model);

                    if (this.model.position.x < -400 || this.model.position.x > 400 || this.model.position.y < -300 || this.model.position.y > 300) {
                        this.resetPosition();
                    }
                }
            }

            let lateralSpeed2 = 1;
            let VerticalSpeed2 = 1;
            let scoreDos = 0;

            let invulnerableTimeDos = 0;
            let slowBulletTimeDos = 0;
            let speedBoostTimeDos = 0;

            function checkCollisionsDos() {
                if (!secondObject) return false;

                const rocketBoxDos = new THREE.Box3().setFromObject(secondObject);

                if (secondModelo1) {
                    const escudoBoxDos = new THREE.Box3().setFromObject(secondModelo1);
                    if (rocketBoxDos.intersectsBox(escudoBoxDos)) {
                        if (invulnerableTimeDos <= 0) {
                            invulnerableTimeDos = 16 * 60;
                            console.log('Colisión detectada con escudo dos');
                            secondModelo1.visible = false;
                        }
                    }
                }

                if (secondModelo2) {
                    const rayoBoxDos = new THREE.Box3().setFromObject(secondModelo2);
                    if (rocketBoxDos.intersectsBox(rayoBoxDos)) {
                        if (speedBoostTimeDos <= 0) {
                            speedBoostTimeDos = 16 * 60;

                            lateralSpeed2 *= 2;
                            VerticalSpeed2 *= 2;
                            console.log('Colisión detectada con rayo dos');
                            secondModelo2.visible = false;
                        }
                    }
                }

                if (secondModelo3) {
                    const relojBoxDos = new THREE.Box3().setFromObject(secondModelo3);
                    if (rocketBoxDos.intersectsBox(relojBoxDos)) {
                        if (slowBulletTimeDos <= 0) {
                            slowBulletTimeDos = 16 * 60;
                            console.log('Colisión detectada con reloj dos');
                            for (const bullet of enemyBulletsDos) {
                                bullet.direction.multiplyScalar(0.5); // Ralentizar la velocidad de las balas a la mitad
                            }
                            secondModelo3.visible = false;
                        }
                    }
                }

                if (invulnerableTimeDos <= 0) {
                    for (const bullet of enemyBulletsDos) {
                        if (rocketBoxDos.intersectsBox(bullet.box)) {
                            if (isPaused === false) {
                                DeadDos = true;
                            } else if (isPaused === true) {
                                DeadDos = true;
                                localStorage.setItem('username', 'indefinido');
                                localStorage.setItem('Puntuacion', score);

                                window.location.href = `MenuDead.html?score=${score}`;
                            } else {
                                DeadDos = true;
                                return true;
                            }
                        }
                    }
                }

                return false;
            }

            // Función de animación para la segunda escena
            function animateSecondScene() {
                if (DeadDos === true) {
                    return;
                }
                requestAnimationFrame(animateSecondScene);

                if (invulnerableTimeDos > 0) {
                    invulnerableTimeDos -= 1;
                    if (invulnerableTimeDos <= 0) {
                        const positionE = getRandomPosition();
                        secondModelo1.position.set(positionE.x, positionE.y, 0);
                        secondModelo1.visible = true;
                    }
                }

                if (slowBulletTimeDos > 0) {
                    slowBulletTimeDos -= 1;
                    if (slowBulletTimeDos <= 0) {
                        for (const bullet of enemyBulletsDos) {
                            bullet.speed *= 2; // Restaurar la velocidad de las balas
                        }
                        const positionR = getRandomPosition();
                        secondModelo3.position.set(positionR.x, positionR.y, 0);
                        secondModelo3.visible = true; // Hacer visible el rayo de nuevo
                    }
                }

                if (speedBoostTimeDos > 0) {
                    speedBoostTimeDos -= 1;
                    if (speedBoostTimeDos <= 0) {
                        lateralSpeed2 /= 2; // Restaurar la velocidad lateral del cohete
                        VerticalSpeed2 /= 2; // Restaurar la velocidad vertical del cohete
                        const positionS = getRandomPosition();
                        secondModelo2.position.set(positionS.x, positionS.y, 0);
                        secondModelo2.visible = true; // Hacer visible el reloj de nuevo
                    }
                }

                backgroundCubed.rotation.x += rotationSpeedX;
                backgroundCubed.rotation.y += rotationSpeedY;

                if (keysState['j'] || keysState['J']) {
                    // Mover el modelo hacia la izquierda
                    if (secondObject && secondObject.position.x - lateralSpeed2 >= -150) {
                        secondObject.position.x -= lateralSpeed2;
                    }
                }
                if (keysState['l'] || keysState['L']) {
                    // Mover el modelo hacia la derecha
                    if (secondObject && secondObject.position.x + lateralSpeed2 <= 80) {
                        secondObject.position.x += lateralSpeed2;
                    }
                }
                if (keysState['i'] || keysState['I']) {
                    // Mover el modelo hacia arriba
                    if (secondObject && secondObject.position.x + VerticalSpeed2 <= 70) {
                        secondObject.position.y += VerticalSpeed2;
                    }
                }
                if (keysState['k'] || keysState['K']) {
                    // Mover el modelo hacia abajo
                    if (secondObject && secondObject.position.x + VerticalSpeed2 >= -44) {
                        secondObject.position.y -= VerticalSpeed2;
                    }
                }

                if (secondObject) {
                    box1.setFromObject(secondObject);
                    enemyBulletsDos.forEach((bullet) => {
                        bullet.update(secondObject);
                        if (box3.intersectsBox(bullet.box)) {
                            console.log('Colisión detectada Dos');
                        }
                    });
                }

                controls.update();
                secondRenderer.render(secondScene, secondCamera);

                if (!isPausedDos) {
                    scoreDos++;
                    document.getElementById('scoreD').innerText = `Puntos: ${scoreDos}`;
                }

                if (checkCollisionsDos()) {
                    isPausedDos = true;
                }
            }
            animateSecondScene();

        }

    </script>


</body>


</html>