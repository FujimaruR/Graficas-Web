<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/Front/recursos/icono.png">
    <title>INFINITE SPACE</title>
    <link rel="stylesheet" href="/Front/css/MainGame.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>

<body>
    <div class="contenedor-todo">
        <div class="caja-blanca" id="MostrarMap">
            <!--<img src="/Front/recursos/cuadro-blanco.png.jpg" alt="invalid-img" class="box" id="box">-->
        </div>

        <div class="letra">
            <img src="/Front/recursos/PUNTOS.png" alt="invalid-img" class="box1" id="box1">
        </div>

        <a href="MenuPause.html">
            <div class="pause">
                <img src="/Front/recursos/pausa (3).png" alt="invalid-img" class="box5" id="box5">
            </div>
        </a>

        <div class="logo">
            <img src="/Front/recursos/logo.png" alt="initial-scale" class="box6" id="box6">
        </div>

        <div class="players">
            <img src="/Front/recursos/Imagenes/1jugadores.png" alt="invalid-img" class="box5" id="box7">
        </div>
    </div>

    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>-->

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
    <!--<script src="/Back/MainGame.js"></script>-->

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OBJLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/OBJLoader';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls';

        // Crear una escena
        const scene = new THREE.Scene();

        // Crear una cámara
        // Crear una cámara
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 110); // Posición de la cámara
        camera.lookAt(0, 0, 0); // Mirar hacia el origen de la escena


        // Crear un renderizador con dimensiones específicas
        const renderer = new THREE.WebGLRenderer({ width: 800, height: 600 });
        renderer.setSize(800, 600);
        document.getElementById('MostrarMap').appendChild(renderer.domElement);


        // Agregar una luz ambiental
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Color, intensidad
        scene.add(ambientLight);

        // Agregar una luz direccional
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // Color, intensidad
        directionalLight.position.set(0, 1, 0); // Posición de la luz
        scene.add(directionalLight);

        // Crear controles de órbita
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Suavizado del movimiento de los controles
        controls.dampingFactor = 0.25; // Factor de amortiguación

        // Cargar la textura del fondo
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const imagen = urlParams.get('imagen');
        const textureLoader = new THREE.TextureLoader();
        const texture = textureLoader.load('/Front/recursos/Mapas/' + imagen);

        // Crear un material con la textura del fondo
        const backgroundMaterial = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });

        // Crear un cubo grande para el fondo
        const backgroundGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
        const backgroundCube = new THREE.Mesh(backgroundGeometry, backgroundMaterial);

        // Agregar el cubo del fondo a la escena
        scene.add(backgroundCube);


        let object;

        // Cargar el modelo OBJ
        const loader = new OBJLoader();
        loader.load(
            '/Front/recursos/Modelos/Cohete1/10475_Rocket_Ship_v1_L3.obj',
            function (loadedObject) {

                object = loadedObject;

                        // Cargar la textura para el modelo
                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load('/Front/recursos/Modelos/Cohete1/10475_Rocket_Ship_v1_Diffuse.jpg');

                // Crear un material con la textura cargada
                const material = new THREE.MeshBasicMaterial({ map: texture });

                // Aplicar el material al objeto
                object.traverse(function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                });

                // Ajustar la posición del modelo
                object.position.set(-45, -78, 0); // Modificar según sea necesario
                object.rotation.set(180, -0.1, 0.3);

                // Ajustar la escala del modelo
                object.scale.set(0.1, 0.1, 0.1); // Modificar según sea necesario

                scene.add(object);
            },
            function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (error) {
                console.error('Error loading OBJ file:', error);
            }
        );

        let objectSol;

        const loaderDos = new OBJLoader();
        loaderDos.load(
            '/Front/recursos/Modelos/Bala/sol.obj',
            function (loadedObjectD) {

                objectSol = loadedObjectD;
                // Ajustar la posición del modelo
                objectSol.position.set(-45, 40, 0); // Modificar según sea necesario
                objectSol.rotation.set(180, -0.1, 0.3);

                // Ajustar la escala del modelo
                objectSol.scale.set(0.0004, 0.0004, 0.0004); // Modificar según sea necesario

                scene.add(objectSol);
            },
            function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (error) {
                console.error('Error loading OBJ file:', error);
            }
        );

        const keysState = {};

        // Escuchar eventos de teclado
        document.addEventListener('keydown', (event) => {
            // Marcar la tecla como activa en el objeto keysState
            keysState[event.key] = true;
        });

        document.addEventListener('keyup', (event) => {
            // Desmarcar la tecla como activa en el objeto keysState
            keysState[event.key] = false;
        });

        const lateralSpeed = 1;
        const VerticalSpeed = 1;

        // Función de animación
        function animate() {
            requestAnimationFrame(animate);

            if (keysState['a'] || keysState['A']) {
                // Mover el modelo hacia la izquierda
                if (object && object.position.x - lateralSpeed >= -150) {
                    object.position.x -= lateralSpeed;
                }
            }
            if (keysState['d'] || keysState['D']) {
                // Mover el modelo hacia la derecha
                if (object && object.position.x + lateralSpeed <= 80) {
                    object.position.x += lateralSpeed;
                }
            }
            if (keysState['w'] || keysState['W']) {
                // Mover el modelo hacia arriba
                if (object && object.position.x + VerticalSpeed <= 70) {
                    object.position.y += VerticalSpeed;
                }
            }
            if (keysState['s'] || keysState['S']) {
                // Mover el modelo hacia abajo
                if (object && object.position.x + VerticalSpeed >= -100) {
                    object.position.y -= VerticalSpeed;
                }
            }


            controls.update(); // Actualizar controles de órbita
            renderer.render(scene, camera);
        }
        animate();

        // Obtener la consulta de la URL

        // Verificar si el parámetro 'jugadores' está presente y tiene el valor 2
        if (urlParams.has('jugadores') && urlParams.get('jugadores') === '2') {

            var segundaCajaBlanca = document.createElement('div');
            segundaCajaBlanca.className = 'caja-blanca segunda-caja-blanca'; // Asigna una clase diferente para el segundo contenedor
            segundaCajaBlanca.id = 'box2'
            document.body.appendChild(segundaCajaBlanca);

            var primeraCajaBlanca = document.querySelector('.caja-blanca');
            primeraCajaBlanca.style.right = '55%';



            // Crear una segunda escena, cámara y renderizador
            const secondScene = new THREE.Scene();
            const secondCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            secondCamera.position.set(0, 0, 110);
            secondCamera.lookAt(0, 0, 0);
            const secondRenderer = new THREE.WebGLRenderer({ width: 800, height: 600 });
            secondRenderer.setSize(800, 600);
            document.getElementById('box2').appendChild(secondRenderer.domElement);

            // Crear una segunda luz ambiental y direccional
            const secondAmbientLight = new THREE.AmbientLight(0xffffff, 0.5);
            secondScene.add(secondAmbientLight);
            const secondDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            secondDirectionalLight.position.set(0, 1, 0);
            secondScene.add(secondDirectionalLight);

            const imagend = urlParams.get('imagen');
            const textureLoaderd = new THREE.TextureLoader();
            const textured = textureLoaderd.load('/Front/recursos/Mapas/' + imagend);

            // Crear un material con la textura del fondo
            const backgroundMateriald = new THREE.MeshBasicMaterial({ map: textured, side: THREE.BackSide });

            // Crear un cubo grande para el fondo
            const backgroundGeometryd = new THREE.BoxGeometry(1000, 1000, 1000);
            const backgroundCubed = new THREE.Mesh(backgroundGeometryd, backgroundMateriald);

            // Agregar el cubo del fondo a la escena
            secondScene.add(backgroundCubed);

            let secondObject;

            // Cargar el modelo OBJ en la segunda escena
            const secondLoader = new OBJLoader();
            secondLoader.load(
                '/Front/recursos/Modelos/Cohete2/Cohete2.obj',
                function (SecondloadedObject) {
                    secondObject = SecondloadedObject;
                    // Cargar la textura para el segundo modelo
                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load('/Front/recursos/Modelos/Cohete2/Textura2Cohete.jpg');

                // Crear un material con la textura cargada
                const material = new THREE.MeshBasicMaterial({ map: texture });

                // Aplicar el material al objeto
                secondObject.traverse(function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                });
                    secondObject.position.set(-45, -78, 0);
                    secondObject.rotation.set(180, -0.1, 0.3);
                    secondObject.scale.set(0.1, 0.1, 0.1);
                    secondScene.add(secondObject);
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('Error loading OBJ file:', error);
                }
            );

            const keysStateDos = {};

            // Escuchar eventos de teclado
            document.addEventListener('keydown', (event) => {
                // Marcar la tecla como activa en el objeto keysState
                keysStateDos[event.key] = true;
            });

            document.addEventListener('keyup', (event) => {
                // Desmarcar la tecla como activa en el objeto keysState
                keysStateDos[event.key] = false;
            });

            const lateralSpeed2 = 1;
            const VerticalSpeed2 = 1;

            // Función de animación para la segunda escena
            function animateSecondScene() {
                requestAnimationFrame(animateSecondScene);

                if (keysState['j'] || keysState['J']) {
                    // Mover el modelo hacia la izquierda
                    if (secondObject && secondObject.position.x - lateralSpeed2 >= -150) {
                        secondObject.position.x -= lateralSpeed2;
                    }
                }
                if (keysState['l'] || keysState['L']) {
                    // Mover el modelo hacia la derecha
                    if (secondObject && secondObject.position.x + lateralSpeed2 <= 80) {
                        secondObject.position.x += lateralSpeed2;
                    }
                }
                if (keysState['i'] || keysState['I']) {
                    // Mover el modelo hacia arriba
                    if (secondObject && secondObject.position.x + VerticalSpeed2 <= 70) {
                        secondObject.position.y += VerticalSpeed2;
                    }
                }
                if (keysState['k'] || keysState['K']) {
                    // Mover el modelo hacia abajo
                    if (secondObject && secondObject.position.x + VerticalSpeed2 >= -44) {
                        secondObject.position.y -= VerticalSpeed2;
                    }
                }


                secondRenderer.render(secondScene, secondCamera);
            }
            animateSecondScene();

        }

    </script>


</body>


</html>